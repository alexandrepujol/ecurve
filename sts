#!/usr/bin/env python
#
# sts - STS with elliptic curve.
# Version 1.0
# Year 2014
# Author Alexandre PUJOL <alexandre.pujol.1@etu.univ-amu.fr>
# Author Maxime CHEMIN <maxime.chemin@etu.univ-amu.fr>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License.
#

import argparse
import socket
from elliptic import *
from tools import *
from STS import *
import struct

""" Generate STS key (same than DH key)
 Input :
 - Curve (default : curves/w256-001.gp)
 Output :
 - Private key (default : keys/sts)
"""
def Keygen():
   print(":: Keygen")
   
   if arg.key is not False or arg.host is not False :
      raise Exception('Argument error')
   if arg.host is not False or arg.port is not False:
      raise Exception('Argument error')
      
   if arg.curve is False:
      arg.curve = 'curves/w256-001.gp'

   if arg.output is False:
      arg.output = 'keys/sts'
      
   print(" Load curve : " + arg.curve)
   curve = tools.loadCurve(arg.curve)
   
   sts = STS(curve)
   
   print(" Generate key")
   x = sts.keygen()
   
   print(" Write private STS key : " + arg.output)
   key.writeKey(arg.output, 'DIFFIEHELLMAN', curve, x)
   
"""
 Input :
 - server (bool)
 - socket (socket)
 - gx (Point)
 Output :
 - gy (Point)
"""   
def secret_exchange(server, socket, gx):
   gx_bytes = (str(gx.x) + "," + str(gx.y)).encode()
   
   if server is True:
      print(" Sending secret to client->gx")
      socket.send(gx_bytes)
   
      print(" gy<-Getting client's secret")
      gy_bytes = socket.recv(4096)
   else:
      print(" Getting server's secret")
      gy_bytes = socket.recv(4096)
      
      print(" Sending secret to server")
      socket.send(gx_bytes)
   
   gy_str = gy_bytes.decode()
   (gy_str_x, gy_str_y) = gy_str.split(',')
   gy = Point(gx.curve, int(gy_str_x), int(gy_str_y))
   return gy
   
"""

"""
def sharedsecret_exchange(server, socket, ecdsa_publickey, encrypted, iv):
   certificat_bytes = (str(ecdsa_publickey.x)+","+str(ecdsa_publickey.y)).encode()
   if server is True:
      print(" Sending to the client :")
      print("  - Public key certificate->cert")
      socket.send(certificat_bytes)
      print("  - Signature encrypted->sign")
      message.send(socket, encrypted)
      message.send(socket, iv)

      print(" <-Getting from the client :")
      print("  - Public key certificate")
      certificat_bytes_new = socket.recv(4096)
      
      print("  - Signature encrypted")
      encrypted_new = message.get(socket)
      iv_new = message.get(socket)
   else:
      print(" Getting from the server :")
      print("  - Public key certificate")
      certificat_bytes_new = socket.recv(4096)
      print("  - Signature encrypted")
      encrypted_new = message.get(socket)
      iv_new = message.get(socket)
      
      print(" Sending to the server :")
      print("  - Public key certificate")
      socket.send(certificat_bytes)

      print("  - Signature encrypted")
      message.send(socket, encrypted)
      message.send(socket, iv)
   
   certificat_str = certificat_bytes_new.decode()
   (certificat_str_x, certificat_str_y) = certificat_str.split(',')
   certificat_new = Point(ecdsa_publickey.curve, int(certificat_str_x), int(certificat_str_y))
   return (certificat_new, encrypted_new, iv_new)
   
""" Share
 Input :
 - Private key (default : keys/sts)
 - Host (default : localhost)
 - Host's port (default : 12800)
 Output :
 - Shared secret (default : keys/sts.shared)
"""
def Share():
   print(":: Share key")
   
   if arg.curve is not False:
      raise Exception('Argument error')
      
   if arg.key is False:
      arg.key = 'keys/sts'
   
   if arg.cert is False:
      arg.cert = 'keys/ecdsa'
      
   if arg.host is False:
      arg.host = 'localhost'
      
   if arg.port is False:
      arg.port = 12800
   else:
      arg.port = int(arg.port)
      
   if arg.output is False:
      arg.output = 'keys/sts.shared'
            
   print(" Read privatekey key : " + arg.key)
   (curve, x) = key.readKey(arg.key)
   
   sts = STS(curve)
   
   print(" Compute : g^x")
   gx = sts.secret(x)
   
   print(" Read ECDSA keys (certificat) : " + arg.cert + ".pub")
   (curve2, ecdsa_publickey) = key.readKey(arg.cert + ".pub")
   (curve3, ecdsa_privatekey) = key.readKey(arg.cert)
   print(ecdsa_publickey)
   if curve != curve2 or curve != curve3:
      print (curve.p,curve.n,curve.a4,curve.a6) == (curve2.p,curve2.n,curve2.a4,curve2.a6)
      raise Exception('ECDSA keys are not on the same curve than DH secret')
      
   # Exchange
   if arg.server is True:
      server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
      server.bind(('', arg.port))
      server.listen(1)
      print(" Server started")
      print(" Waiting for client connection...")
      (exchange, address) = server.accept()
      print(" Server connected to : " + str(address))
   else:
      exchange = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
      exchange.connect((arg.host, arg.port))
      print(" Connected to : " + arg.host + " on port " + str(arg.port))

   gy = secret_exchange(arg.server, exchange, gx)
   
   print(" Compute : Signed and encrypt it")
   (K, encrypted, iv) = sts.sharedsecret(ecdsa_privatekey, x, gx, gy)
      
   (certificat_new, encrypted_new, iv_new) = sharedsecret_exchange(arg.server, exchange, ecdsa_publickey, encrypted, iv)
      
   print(" Closing connection")
   exchange.close()
   if arg.server is True:
      server.close()
      
   
      
   print(" Verification")
   print("x         : " + str(x))
   print("gx        : " + str(gx))
   print("gy        : " + str(gy))
   print("iv        : " + str(iv_new))
   print("encrypted : " + str(encrypted_new))
   print("certificat: " + str(certificat_new))
   
   #print(" Write shared secret in " + arg.output)
   #key.writeKey(arg.output, 'DIFFIEHELLMAN', curve, gxy)
   

parser = argparse.ArgumentParser(description='Diffie Hellman with elliptic curve.')
parser.add_argument( '-K','--keygen',
                     action='store_const', dest='prgm', const='keygen',
                     help='Generate STS private key')
parser.add_argument( '-S', '--share',
                     action='store_const', dest='prgm', const='share',
                     help='Share key with an other computer')
parser.add_argument( '-c', '--curve',
                     action='store', default=False, dest='curve',
                     help='Load a specific elliptic curve ')
parser.add_argument( '-k', '--key',
                     action='store', default=False, dest='key',
                     help='Load  key')
parser.add_argument( '-t', '--cert',
                     action='store', default=False, dest='cert',
                     help='Load certificat')
parser.add_argument( '--host',
                     action='store', default=False, dest='host',
                     help='Hostname or IP of the other computer')
parser.add_argument( '--port',
                     action='store', default=False, dest='port',
                     help='Hostname\'s port')
parser.add_argument( '-o', '--output',
                     action='store', default=False, dest='output',
                     help='Output file')
parser.add_argument( '-s', '--server',
                     action='store_true', default=False, dest='server',
                     help='Create server connection')
parser.add_argument( '-v', '--version', 
                     action='version', version='%(prog)s 1.0')
arg = parser.parse_args()

if arg.prgm is 'keygen':
   Keygen()
elif arg.prgm is 'share':
   Share()
else:
   raise Exception('Argument error')
   
